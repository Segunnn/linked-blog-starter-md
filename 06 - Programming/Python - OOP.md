#Python 

----

##### Все классы в Python неявно наследуются от класса `Object`

```python
class MyClass:
	attribute = 0 # Это аттрибут класса

	def __init__(self) -> None:
		self.x = 0 # Это аттрибут объекта
```

## Встроенные методы

`__dict__` - *Возвращает список всех атрибутов класса. Можно заменить на vars()*

`__dir__` - *Возвращает список всех атрибутов и методов без их значений. Можно заменить на dir()*

`__setattr__(self, name, value)` - *Вызывается при изменении атрибута ` key` класса*
`__getattribute__(self, name)` - *Вызывается при получении атрибута `name` класса. Изначальный функционал этого метода -> `return object.__getattribute__(self, name)`. При изменении этого функционала, можно ограничить доступ к некоторым атрибутам в ручную*
`__delattr__(self, name)` - *Вызывается при удалении атрибута `name` класса*
`__getattr__(self, name)` - *Вызывается при попытке обращения к несуществующему атрибуту*

`__getitem__()` - Используется для итерации объекта, `Object[2]`
`__setitem__()` - Используется для изменения элементов через итерацию объекта, `Object[2] = 6`
`__delitem__()` - Для удаления элементов, `del Object[2]`
## Магические методы

`__init__(self, ...)` - *Инициализатор объекта класса, вызывается при создание объекта.*

`__del__(self, ...)` - *Финализатор объекта класса, вызывается перед удалением объекта*

`__new__()` - *Вызывается перед созданием объекта, используется в паттерне Singleton. Для инициализации класса с использованием `__new__` надо в этот метод добавить строку `return super().__new__(cls)`*

`__call__(self, *args, **kwargs)` - Изначально этот метод не определен и при попытке вызвать объект класса с помощью круглых скобок высветиться ошибка, но если его определить, то класс можно будет вызывать.

`__str__()` - Используется для отображения информации об объекте класса.
`__repr__()` -  Используется для отображения информации для отладки.
`__len__()`, `__abs__()` - Позволяют применять одноименные функции к объектам класса.

#### Арифметические

`__add__` - Операции сложения. Есть еще `__radd__` для сложения других типов данных с нашим классом и `__iadd__` для `+=`. Обе этих версии присутствуют и в других арифметических методах.
`__sub__` - Операции вычитания
`__mul__` - Операции умножения
`__truediv__` - Операции деления

#### Сравнения
`__eq__()` - для равенства "\=\="
`__ne__()` - для неравенства "!=" 
`__lt__()` - для оператора "<"
`__le__()` - для оператора "<="
`__gt__()` - для оператора ">"
`__ge__()` - для оператора ">="


## Декораторы

`@property`:
```python
@property
def bal(self) -> int:
	print("Getter is used")
	return self.__balance

@bal.setter
def bal(self, bal: int) -> None:
	print("Setter is used")
	self.__balance = bal
```
*С помощью такого подхода можно изменять атрибут `__balance` обращаясь просто к `bal`. Пример:*

```python
u = User('Adolf', 14)

u.bal = 88

print(u.bal)
```
*Атрибут `__balance` теперь равен 88. Можно также определить `@bal.deleter`*

`@classmethod -> cls` - *Метод класса, не требует `self`, поэтому к объектам класса отношения не имеет. К методу класса можно обращаться даже не создавая объект класса*

`@staticmethod -> None` - *Не имеет отношения не к атрибутам класса, не к атрибутам его объектов. К статическому методу можно обращаться даже не создавая объект класса*


## Инкапсуляция
*Нормальную инкапсуляцию можно реализовать с помощью модуля accessify*
- `attribute` - Обычная переменная, тип *Public* (Доступна в классе и вне класса)
- `_attribute` - Переменная с нижним подчеркиванием в начале автоматически приобретает тип *Protected* (Доступен только внутри класса и во всех его дочерних классах). Этот тип служит чисто декоративным.
- `__attribute` - Два нижних подчеркивания - тип *Private* (Обращаться можно только внутри класса). Этот тип действительно ограничивает доступ извне класса. Можно получить значение такого атрибута обращаясь к `_ClassName__attribute`
- К методам также относится

### Дескриптор
Это класс содержащий магический метод `__get__(self, instance, owner)` (non-data descriptor) 
или data descriptor если у него есть эти методы: `__get__(self, isinstance, owner)`, `__set__(self, instance, owner)`, `__del__(self)`
В классе дескрипторе данных, owner - класс, в котором мы создаем объект нашего дескриптора, instance - ссылка на объект класса owner.