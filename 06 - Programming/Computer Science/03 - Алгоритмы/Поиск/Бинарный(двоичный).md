#Программирование 

----



| Значение | 3 | 4 | 15 | 17 | 20 | 23 | 24 | 31 | 33 | 37 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- |
| Индекс | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

**Цель: Найти индекс ячейки с значением 33**

**Вариант №1: С помощью [[Линейный]] поиска**

**Вариант №2: Бинарный:  Сложность: O(log N)** 
Если линейный поиск проходится по каждому элементу один за другим, бинарный поиск поступает более умно, он **сравнивает целевое значение с значением центральной ячейки** и, в зависимости от результата, обрезает область поиска влево или вправо.

_Если значение центральной клетки равно цели:_
Возвращаем успех
_Если значение центральной клетки больше цели:_
Обрезаем область поиска вправо, то-есть область поиска теперь такая:

| 3 | 4 | 15 | 17 |
| :--: | :--: | :--: | :--: |
| 0 | 1 | 2 | 3 |
_Если значение центральной клетки меньше цели:_
Обрезаем область поиска влево:

| 23 | 24 | 31 | 33 | 37 |
| :--: | :--: | :--: | :--: | ---- |
| 5 | 6 | 7 | 8 |    9 |

##### Повторяем все эти действия пока курсоры не встретятся на одной ячейке, либо не будет найден искомый элемент

### Реализация на Python

```python
def binary(num_array: tuple, target: int) -> bool:

    # Сортируем список
    num_array = sorted(num_array)

    # Создаем два курсора, в разные концы списка
    left, right = (0, len(num_array) - 1)

    # Если левый курсор попал на правую сторону, значит искомого элемента нет в списке
    while (left <= right):

        # Задаем "Курсор в середине" (Делим длинну области поиска на 2 без остатка)
        middle = (low+hight) // 2

        # Значение нашего среднего курсора
        guess = num_array[middle]

        if (guess == target):
            result = True
            return middle

        # Если средняя ячейка > цели, обрезаем список справа
        elif (guess > target): 
            hight = middle - 1

        # В противном случае обрезаем список слева
        else:
	            low = middle + 1

    return 0

```
